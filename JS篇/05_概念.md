1、闭包是什么？闭包的用途？
  闭包其实就是个closure对象。
  闭包形成的原理：作用域链，当前作用域可以访问上级作用域中的变量 
  闭包解决的问题：能够让函数作用域中的变量在函数执行结束之后不被销毁，同时也能在函数内部可以访问函数外部的局部变量。
  闭包带来的问题：由于垃圾回收器不会将闭包中的变量销毁，于是就造成了内存泄露，内存泄露积累多了就容易导致内存溢出。
  闭包的应用：能够模仿块级作用域，能够实现柯里化，在构造函数中定义特权方法、Vue中数据响应式Observer中使用闭包等。

  怎么实现柯里化？

2、简述事件循环原理？
    JS是单线程的，同一时间只能做一件事情。在执行JS代码的时候，遇见同步任务，直接推入调用栈中执行，遇到异步任务，会将该任务挂起，等到异步任务有返回之后推入到任务队列中，当调用栈中的同步任务全部执行完成，将任务队列中的任务按顺序一个一个的推入并执行，重复执行这一系列的行为。
    其中异步任务分为宏任务和微任务。
    宏任务：宏任务队列中的任务称为宏任务，每一个宏任务中都包含一个微任务队列。
    微任务：等当前宏任务执行完成后，渲染引擎并不会立即执行下一个宏任务，而是先把当前宏任务中的微任务执行完成再去执行下一个宏任务。

    浏览器和Node环境下，microtask 任务队列的执行时机不同。
    Node端：microtask 在事件循环的各个阶段之间执行。
    浏览器端：microtask 在事件循环的 macrotask 执行完之后执行。

    宏任务和微任务的区分是为了做什么? 优先级?
    是的，区分微任务和宏任务的根本原因是为了插队。
    微任务是线程之间的切换，速度快。不用进行上下文切换，可以快速的一次性做完所有的微任务。

    宏任务是进程之间的切换，速度慢，且每次执行需要切换上下文。因此一个Eventloop中只执行一个宏任务。
    由于微任务执行快，一次性可以执行很多个，在当前宏任务执行后立刻清空微任务可以达到伪同步的效果，这对视图渲染效果起到至关重要的作用。

    什么是线程，进程？

3、虚拟dom是什么? 原理? 优缺点?
    虚拟dom本质上是javascript对象，是对真实dom的抽象，通过js对象的属性来描述真实的dom。在状态发生变更时，记录新树和旧树的差异，最后把差异更新到真实dom中。
    优点：
    1、性能优化
    2、无需手动操作dom
    3、跨平台
    缺点：
    1、无法进行极致优化
4、跨域
  导致跨域的原因是浏览器的同源协议策略。当前页面中的接口请求地址和当前页面的的地址在协议、域名、端口不一致的情况下就会产生跨域。
  解决跨域的主要方式：JSONP、CORS、iframe的postMessage、node中间件或者nginx做代理（把请求发给代理服务器，然后代理服务器再向后端服务器发请求，服务器和服务器之间是不存在跨域限制的。）
5、Vue和react在技术层面的区别：
  1、都是采用组件化思想，将页面切分成一个一个的可复用单元，从而提高开发效率和代码复用。
  2、都采用了虚拟dom，通过操作虚拟dom来提高渲染效率。
  3、都采用了虚拟dom的diff算法，只是diff算法的过程有所不同，react采用的diff算法是自顶向下逐级对比，vue采用的是双端比较法，同样情况下可以减少对比次数，减少性能消耗。
  4、都是通过数据驱动视图，单向数据流，数据在某个节点发生改变后，只会影响一个方向上的节点。
6、async、await的原理是什么？
  async是Generator函数的语法糖，自带执行器。await是配合async使用，而且也只能在async内部使用，正常情况下后面跟的是promise对象。如果不是，会被转成一个立即resolve的Promise对象。只要有一个await语句后面的Promise变为reject状态，那么整个async函数都会中断执行。
7、async/await, generator, promise这三者的关联和区别是什么?
  generator和promise都是ES6提供的一种异步编程解决方案。
  async是generator函数的语法糖，自带执行器。返回值是promise对象。
  generator函数返回的是一个遍历器对象。遍历器对象（Iterator）本质上就是一个指针对象，可以通过调用指针对象的next方法，将指针指向数据结构的相应成员。
8、Set和Map
  Set和Map都是ES6提供的数据结构。
  Set实例方法分为两大类：
  操作方法：add(value)、delete(value)、has(value)、clear()
  遍历方法：keys()、values()、entries()、forEach()
  Set的遍历顺序就是插入顺序。这个特性有时非常有用，比如使用Set保存一个回调函数列表，调用时就能保证按照添加顺序调用。
  Map实例的属性和操作方法：
  size属性、set(key, value)、get(key)、has(key)、delete(key)、clear()
  遍历方法：keys()、values()、entries()、forEach()
9、ES5和ES6的继承? 这两种方式除了写法, 还有其他区别吗?
  ES6通过extends关键字实现继承。ES5通过修改原型链实现继承。相对而言，ES6的继承方式更加清晰和方便。
  ES5的继承实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。
  ES6的继承机制完全不同，实质是先创造父类实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。
10、浏览器从输入url开始发生了什么？
  1.DNS对域名进行解析；
  2.建立TCP连接（三次握手）；
  3.发送HTTP请求；
  4.服务器处理请求；
  5.返回响应结果；
  6.关闭TCP连接（四次挥手）；
  7.浏览器解析HTML；
  8.浏览器布局渲染；
  html解析->外部样式、脚本加载->外部样式执行->外部脚本执行->html继续解析->dom树构建完成->加载图片->页面加载完成
11、defer和async
    ①defer和async都属于异步加载，只对外部js脚本有效。
    ②defer是延迟执行（当前html页面解析完成后执行）js，async是当前js文件加载完成后执行js
    普通外部js文件属于同步加载。
12、Generator函数暂停恢复执行原理？
  先了解个概念：
  协程：一个线程或函数执行到一半，可以暂停执行，将执行权交给另一个线程或函数，等到稍后收回执行权的时候，再恢复执行。这种可以并行执行，交换执行的线程或函数，称为协程。
  协程是一种比线程更加轻量级的存在。普通线程是抢先式的，会争夺cpu资源，而协程是合作的，可以把协程看成是跑在线程上的任务，一个线程上可以存在多个协程，但是在线程上同时只能执行一个协程。它的运行流程大致如下：
    协程A开始执行
    协程A执行到某个阶段，进入暂停，执行权转移到协程B
    协程B执行完成或暂停，将执行权交还A
    协程A恢复执行
  协程遇到yield命令就暂停，等到执行权返回，再从暂停的地方继续往后执行。它的最大优点，就是代码的写法非常像同步操作，如果去除yield命令，简直一模一样。
